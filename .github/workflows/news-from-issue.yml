name: "News from Issue"

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: read
workflow_dispatch:
jobs:
  build-news:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Parse issue (title, date, lang, slug, body)
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const issue = context.payload.issue || {};
            const rawTitle = (issue.title || "").trim();
            const rawBody  = (issue.body  || "").trim();

            if (!rawTitle) { core.setFailed("Missing Issue Title"); return; }
            if (!rawBody)  { core.setFailed("Missing Issue Body (write the article text)"); return; }

            // Language: "Language: en|sv|sr" anywhere, default en
            const langMatch = rawBody.match(/^\s*Language:\s*(en|sv|sr)\s*$/im);
            const lang = (langMatch ? langMatch[1].toLowerCase() : "en");

            // Clean body: drop the Language line and scaffold headings
            const bodyClean = rawBody
              .replace(/^\s*Language:\s*(en|sv|sr)\s*$/gim, "")
              .replace(/^###\s*Date[\s\S]*?(\r?\n){2}/im, "")
              .replace(/^###\s*Language[\s\S]*?(\r?\n){2}/im, "")
              .replace(/^###\s*Body\s*/im, "")
              .trim();

            if (bodyClean.length < 20) {
              core.setFailed("Body too short (min 20 chars)"); return;
            }

            // Title: strip leading date and optional "News:"
            const title = rawTitle
              .replace(/^\s*\d{2}-\d{2}-\d{4}\s*[:â€“-]\s*/,"")
              .replace(/^News:\s*/,"")
              .trim();

            // --- Date handling: ALWAYS dd-mm-yyyy, Europe/Stockholm ---
            function todaySE() {
              const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: 'Europe/Stockholm', day:'2-digit', month:'2-digit', year:'numeric'
              }).formatToParts(new Date());
              const dd = parts.find(p=>p.type==='day').value;
              const mm = parts.find(p=>p.type==='month').value;
              const yyyy = parts.find(p=>p.type==='year').value;
              return `${dd}-${mm}-${yyyy}`;
            }
            function normDate(s) {
              if (!s || /^no response$/i.test(String(s).trim())) return todaySE();
              const t = String(s).trim();
              let m = /^(\d{2})[-\/](\d{2})[-\/](\d{4})$/.exec(t);
              if (m) return `${m[1]}-${m[2]}-${m[3]}`;
              m = /^(\d{4})[-\/](\d{2})[-\/](\d{2})$/.exec(t);
              if (m) return `${m[3]}-${m[2]}-${m[1]}`;
              const d = new Date(t);
              if (!isNaN(d)) {
                const parts = new Intl.DateTimeFormat('sv-SE', {
                  timeZone: 'Europe/Stockholm', day:'2-digit', month:'2-digit', year:'numeric'
                }).formatToParts(d);
                return `${parts.find(p=>p.type==='day').value}-${parts.find(p=>p.type==='month').value}-${parts.find(p=>p.type==='year').value}`;
              }
              return todaySE();
            }
            // Extract value under "### Date" (blank-line delimited)
            let dateField = "";
            { const m = /###\s*Date\s*[\r\n]+([\s\S]*?)(?:\r?\n){2}/i.exec(rawBody); if (m) dateField = (m[1]||"").trim(); }
            const date_display = normDate(dateField);
            const [day, month, year] = date_display.split("-");

            // Slugify (ASCII, kebab)
            function slugify(s){
              return (s || "news")
                .normalize("NFKD")
                .replace(/[\u0300-\u036f]/g, "")
                .toLowerCase()
                .replace(/&/g, " and ")
                .replace(/[^a-z0-9]+/g, "-")
                .replace(/^-+|-+$/g, "");
            }
            const computedSlug = slugify(title);

            // --- Slug locking via index.json (one entry per date) ---
            const metaPath = "data/news/index.json";
            let index = [];
            if (fs.existsSync(metaPath)) {
              try { index = JSON.parse(fs.readFileSync(metaPath, "utf8")); } catch { index = []; }
            }
            // Reuse existing entry for same dd-mm-yyyy; else mint new
            let entry = index.find(e => e.date === date_display);
            const slug = entry ? entry.slug : computedSlug;
            const basePath = entry ? entry.i18nPath : `i18n/news/${year}/${month}/${day}-${slug}`;
            const imgDir   = `assets/img/news/${year}/${month}/${day}-${slug}`;

            core.info(`Parsed -> date=${date_display}, lang=${lang}, slug=${slug}`);
            core.setOutput("date_display", date_display);
            core.setOutput("year", year);
            core.setOutput("month", month);
            core.setOutput("day", day);
            core.setOutput("slug", slug);
            core.setOutput("lang", lang);
            core.setOutput("title", title);
            core.setOutput("basePath", basePath);
            core.setOutput("imgDir", imgDir);
            core.setOutput("bodyMd", bodyClean);
            core.setOutput("branch", `feat/news-${year}-${month}-${day}-${slug}`);

      - name: Create branch
        run: git switch -c "${{ steps.parse.outputs.branch }}"

      - name: Ensure folders
        run: |
          mkdir -p "${{ steps.parse.outputs.imgDir }}"
          mkdir -p "$(dirname "${{ steps.parse.outputs.basePath }}")"

      - name: Install image tools
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick webp jq

      - name: Download attached images (if any)
        if: ${{ contains(steps.parse.outputs.bodyMd, 'https://user-images.githubusercontent.com') || contains(steps.parse.outputs.bodyMd, 'https://user-images.githubusercontent') || contains(steps.parse.outputs.bodyMd, 'https://github.com/user-attachments') }}
        run: |
          set -e
          cd "${{ steps.parse.outputs.imgDir }}"
          # extract image URLs from original body (GitHub-hosted)
          BODY='${{ github.event.issue.body }}'
          python3 - << 'PY'
import os, re, sys
body = os.environ.get("BODY","")
urls = re.findall(r'https://(?:user-images\.githubusercontent\.com|github\.com/user-attachments)/[^\s)\]]+', body)
for u in dict.fromkeys(urls):
    print(u)
PY
          | while read -r URL; do
              NAME="$(basename "$URL" | cut -d'?' -f1)"
              curl -L "$URL" -o "$NAME"
            done

      - name: Generate 600/1200 JPG + WebP variants
        run: |
          set -e
          cd "${{ steps.parse.outputs.imgDir }}"
          shopt -s nullglob
          for f in *; do
            [[ "$f" == *-600.* || "$f" == *-1200.* ]] && continue
            magick "$f" -auto-orient -resize 1200x1200\> "${f%.*}-1200.jpg"
            magick "$f" -auto-orient -resize 600x600\>   "${f%.*}-600.jpg"
            cwebp -q 85 "${f%.*}-1200.jpg" -o "${f%.*}-1200.webp" >/dev/null 2>&1 || true
            cwebp -q 85 "${f%.*}-600.jpg"  -o "${f%.*}-600.webp"  >/dev/null 2>&1 || true
          done

      - name: Write language JSON
        run: |
          TITLE='${{ steps.parse.outputs.title }}'
          BODY='${{ steps.parse.outputs.bodyMd }}'
          LANG='${{ steps.parse.outputs.lang }}'
          BASE='${{ steps.parse.outputs.basePath }}'
          if [ -z "$TITLE" ] || [ -z "$BODY" ]; then
            echo "Empty title/body. Aborting." >&2
            exit 1
          fi
          mkdir -p "$(dirname "$BASE")"
          printf '{\n  "title": %s,\n  "body": %s\n}\n' \
            "$(jq -Rsa . <<<"$TITLE")" \
            "$(jq -Rsa . <<<"$BODY")" \
            > "${BASE}.${LANG}.json"

      - name: Update metadata list (stack newest on top, lock slug per date)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const metaPath = "data/news/index.json";
            const date_display = '${{ steps.parse.outputs.date_display }}';
            const slug = '${{ steps.parse.outputs.slug }}';
            const basePath = '${{ steps.parse.outputs.basePath }}';

            let index = [];
            if (fs.existsSync(metaPath)) {
              try { index = JSON.parse(fs.readFileSync(metaPath, "utf8")); } catch { index = []; }
            }

            // Upsert a single entry per date
            const existing = index.find(e => e.date === date_display);
            if (existing) {
              if (!existing.slug) existing.slug = slug;
              if (!existing.i18nPath) existing.i18nPath = basePath;
            } else {
              index.push({ date: date_display, slug, i18nPath: basePath });
            }

            // Sort by dd-mm-yyyy descending (latest on top)
            index.sort((a,b) => {
              const [ad,am,ay] = String(a.date).split("-").map(Number);
              const [bd,bm,by] = String(b.date).split("-").map(Number);
              return new Date(by, bm-1, bd) - new Date(ay, am-1, ad);
            });

            fs.mkdirSync(path.dirname(metaPath), { recursive: true });
            fs.writeFileSync(metaPath, JSON.stringify(index, null, 2) + "\n");

      - name: Commit
        run: |
          git add -A
          git commit -m "news: add ${{ steps.parse.outputs.date_display }} ${{ steps.parse.outputs.slug }} (${{ steps.parse.outputs.lang }}) from issue #${{ github.event.issue.number }}"

      - name: Push branch
        run: git push -u origin "${{ steps.parse.outputs.branch }}"

      - name: Open PR
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `news: ${'${{ steps.parse.outputs.date_display }}'} ${'${{ steps.parse.outputs.slug }}'} (${'${{ steps.parse.outputs.lang }}'})`,
              head: '${{ steps.parse.outputs.branch }}',
              base: 'main',
              body: `Automated PR for news post from issue #${context.payload.issue.number}.\n\nDate: ${'${{ steps.parse.outputs.date_display }}'}\nSlug: ${'${{ steps.parse.outputs.slug }}'}\nLang: ${'${{ steps.parse.outputs.lang }}'}\ni18nPath: ${'${{ steps.parse.outputs.basePath }}'}`
            });
            core.info(`PR opened: ${pr.html_url}`)
