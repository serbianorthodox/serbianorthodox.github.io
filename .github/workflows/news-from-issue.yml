name: "News from Issue"

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: read

defaults:
  run:
    shell: bash

jobs:
  build-news:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Parse issue (title, date dd-mm-yyyy, lang, slug, body, paths)
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const issue = context.payload.issue || {};
            const rawTitle = String(issue.title || "").trim();
            const rawBody  = String(issue.body  || "").trim();

            if (!rawTitle) { core.setFailed("Missing Issue Title"); return; }
            if (!rawBody)  { core.setFailed("Missing Issue Body");  return; }

            // Language: first line "Language: en|sv|sr" (case-insensitive). Default en.
            const langMatch = rawBody.match(/^\s*Language:\s*(en|sv|sr)\s*$/im);
            const lang = (langMatch ? langMatch[1].toLowerCase() : "en");

            // Strip scaffolding (keep pure body to store)
            const bodyClean = rawBody
              .replace(/^\s*Language:\s*(en|sv|sr)\s*$/gim, "")
              .replace(/^###\s*Date[\s\S]*?(\r?\n){2}/im, "")
              .replace(/^###\s*Language[\s\S]*?(\r?\n){2}/im, "")
              .replace(/^###\s*Body\s*/im, "")
              .trim();

            if (bodyClean.length < 20) {
              core.setFailed("Body too short (min 20 chars)"); return;
            }

            // Title: drop leading date and "News:" if present
            const title = rawTitle
              .replace(/^\s*\d{2}-\d{2}-\d{4}\s*[:â€“-]\s*/,"")
              .replace(/^News:\s*/,"")
              .trim();

            // Date rules: use ### Date (if valid), else today in Europe/Stockholm. Always dd-mm-yyyy.
            function todaySE() {
              const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: 'Europe/Stockholm', day:'2-digit', month:'2-digit', year:'numeric'
              }).formatToParts(new Date());
              const dd = parts.find(p=>p.type==='day').value;
              const mm = parts.find(p=>p.type==='month').value;
              const yyyy = parts.find(p=>p.type==='year').value;
              return `${dd}-${mm}-${yyyy}`;
            }
            function normDate(s) {
              if (!s || /^no response$/i.test(String(s).trim())) return todaySE();
              const t = String(s).trim();
              let m = /^(\d{2})[-\/](\d{2})[-\/](\d{4})$/.exec(t);
              if (m) return `${m[1]}-${m[2]}-${m[3]}`;
              m = /^(\d{4})[-\/](\d{2})[-\/](\d{2})$/.exec(t);
              if (m) return `${m[3]}-${m[2]}-${m[1]}`;
              const d = new Date(t);
              if (!isNaN(d)) {
                const parts = new Intl.DateTimeFormat('sv-SE', {
                  timeZone: 'Europe/Stockholm', day:'2-digit', month:'2-digit', year:'numeric'
                }).formatToParts(d);
                return `${parts.find(p=>p.type==='day').value}-${parts.find(p=>p.type==='month').value}-${parts.find(p=>p.type==='year').value}`;
              }
              return todaySE();
            }
            // Extract ### Date value (blank-line delimited). We DO NOT strip it if provided.
            let dateField = "";
            { const m = /###\s*Date\s*[\r\n]+([\s\S]*?)(?:\r?\n){2}/i.exec(rawBody); if (m) dateField = (m[1]||"").trim(); }
            const date_display = normDate(dateField);              // dd-mm-yyyy
            const [dd, mm, yyyy] = date_display.split("-");

            // Slugify ASCII-kebab (deterministic)
            function slugify(s){
              return (s || "news")
                .normalize("NFKD").replace(/[\u0300-\u036f]/g, "")
                .toLowerCase().replace(/&/g," and ").replace(/[^a-z0-9]+/g,"-")
                .replace(/^-+|-+$/g,"");
            }
            const computedSlug = slugify(title);

            // Slug locking via index.json: single entry per date (dd-mm-yyyy) so all languages share one slug
            const metaPath = "data/news/index.json";
            let index = [];
            if (fs.existsSync(metaPath)) {
              try { index = JSON.parse(fs.readFileSync(metaPath, "utf8")); } catch { index = []; }
            }
            let entry = index.find(e => e.date === date_display);
            const slug = entry ? entry.slug : computedSlug;
            const basePath = entry ? entry.i18nPath : `i18n/news/${yyyy}/${mm}/${dd}-${slug}`;
            const imgDir   = `assets/img/news/${yyyy}/${mm}/${dd}-${slug}`;

            core.info(`Parsed -> date=${date_display}, lang=${lang}, slug=${slug}`);
            core.setOutput("date_display", date_display);
            core.setOutput("yyyy", yyyy);
            core.setOutput("mm", mm);
            core.setOutput("dd", dd);
            core.setOutput("slug", slug);
            core.setOutput("lang", lang);
            core.setOutput("title", title);
            core.setOutput("basePath", basePath);
            core.setOutput("imgDir", imgDir);
            core.setOutput("bodyMd", bodyClean);
            core.setOutput("branch", `feat/news-${yyyy}-${mm}-${dd}-${slug}`);

      - name: Create branch
        run: git switch -c "${{ steps.parse.outputs.branch }}"

      - name: Ensure folders
        run: |
          mkdir -p "${{ steps.parse.outputs.imgDir }}"
          mkdir -p "$(dirname "${{ steps.parse.outputs.basePath }}")"

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick webp jq

      - name: Download attached images (if any)
        run: |
          set -e
          cd "${{ steps.parse.outputs.imgDir }}"
          BODY='${{ github.event.issue.body }}'
          tmpdir="$(mktemp -d)"
          printf "%s" "$BODY" > "$tmpdir/body.txt"

          # Extract URLs from both user-images and user-attachments, dedupe
          grep -Eo 'https://user-images\.githubusercontent\.com/[^ )]+' "$tmpdir/body.txt" > "$tmpdir/u1.txt" || true
          grep -Eo 'https://github\.com/user-attachments/[^ )]+'      "$tmpdir/body.txt" > "$tmpdir/u2.txt" || true
          cat "$tmpdir/u1.txt" "$tmpdir/u2.txt" 2>/dev/null | awk 'NF && !seen[$0]++' > "$tmpdir/urls.txt"

          while IFS= read -r URL; do
            [ -n "$URL" ] || continue
            NAME="$(basename "$URL" | cut -d'?' -f1)"
            # Skip if a file with same base already exists to avoid triplicating across translations
            if ls "${NAME%.*}"* >/dev/null 2>&1; then
              echo "Skip existing images for ${NAME%.*}"
              continue
            fi
            curl -fsSL "$URL" -o "$NAME" || true
          done < "$tmpdir/urls.txt"

      - name: Generate 600/1200 JPG + WebP variants (skip if too small)
        run: |
          set -e
          cd "${{ steps.parse.outputs.imgDir }}"
          shopt -s nullglob
          for f in *; do
            [[ -f "$f" ]] || continue
            [[ "$f" == *-600.* || "$f" == *-1200.* ]] && continue
            magick "$f" -auto-orient -resize 1200x1200\> "${f%.*}-1200.jpg" || true
            magick "$f" -auto-orient -resize 600x600\>   "${f%.*}-600.jpg"  || true
            [ -f "${f%.*}-1200.jpg" ] && cwebp -q 85 "${f%.*}-1200.jpg" -o "${f%.*}-1200.webp" >/dev/null 2>&1 || true
            [ -f "${f%.*}-600.jpg"  ] && cwebp -q 85 "${f%.*}-600.jpg"  -o "${f%.*}-600.webp"  >/dev/null 2>&1 || true
          done

      - name: Write language JSON
        run: |
          TITLE='${{ steps.parse.outputs.title }}'
          BODY='${{ steps.parse.outputs.bodyMd }}'
          LANG='${{ steps.parse.outputs.lang }}'
          BASE='${{ steps.parse.outputs.basePath }}'
          if [ -z "$TITLE" ] || [ -z "$BODY" ]; then
            echo "Empty title/body. Aborting." >&2
            exit 1
          fi
          mkdir -p "$(dirname "$BASE")"
          printf '{\n  "title": %s,\n  "body": %s\n}\n' \
            "$(jq -Rsa . <<<"$TITLE")" \
            "$(jq -Rsa . <<<"$BODY")" \
            > "${BASE}.${LANG}.json"

      - name: Update metadata list (stack newest on top, lock slug per date)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const metaPath = "data/news/index.json";
            const date_display = '${{ steps.parse.outputs.date_display }}';
            const slug = '${{ steps.parse.outputs.slug }}';
            const basePath = '${{ steps.parse.outputs.basePath }}';

            let index = [];
            if (fs.existsSync(metaPath)) {
              try { index = JSON.parse(fs.readFileSync(metaPath, "utf8")); } catch { index = []; }
            }

            // Upsert one row per date; newest on top
            const existing = index.find(e => e.date === date_display);
            if (existing) {
              if (!existing.slug) existing.slug = slug;
              if (!existing.i18nPath) existing.i18nPath = basePath;
            } else {
              index.push({ date: date_display, slug, i18nPath: basePath });
            }

            // Sort by dd-mm-yyyy desc
            index.sort((a,b) => {
              const [ad,am,ay] = String(a.date).split("-").map(Number);
              const [bd,bm,by] = String(b.date).split("-").map(Number);
              return new Date(by, bm-1, bd) - new Date(ay, am-1, ad);
            });

            fs.mkdirSync(path.dirname(metaPath), { recursive: true });
            fs.writeFileSync(metaPath, JSON.stringify(index, null, 2) + "\n");

      - name: Commit
        run: |
          git add -A
          git commit -m "news: add ${{ steps.parse.outputs.date_display }} ${{ steps.parse.outputs.slug }} (${{ steps.parse.outputs.lang }}) from issue #${{ github.event.issue.number }}" || echo "No changes to commit"

      - name: Push branch
        run: |
          set -e
          # Always push; if nothing changed after commit it's a no-op.
          git push -u origin "${{ steps.parse.outputs.branch }}" || true

      - name: Open PR
        uses: actions/github-script@v7
        with:
          script: |
            const head = '${{ steps.parse.outputs.branch }}';
            const title = `news: ${'${{ steps.parse.outputs.date_display }}'} ${'${{ steps.parse.outputs.slug }}'} (${'${{ steps.parse.outputs.lang }}'})`;
            const body  = `Automated PR from issue #${context.payload.issue.number}\n\nDate: ${'${{ steps.parse.outputs.date_display }}'}\nSlug: ${'${{ steps.parse.outputs.slug }}'}\nLang: ${'${{ steps.parse.outputs.lang }}'}\ni18nPath: ${'${{ steps.parse.outputs.basePath }}'}`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo:  context.repo.repo,
                title, head, base: 'main', body
              });
              core.info(`PR opened: ${pr.html_url}`);
            } catch (e) {
              if (e.status === 422 && /pull request already exists/i.test(e.message)) {
                core.info('PR already exists, skipping.');
              } else {
                throw e;
              }
            }
